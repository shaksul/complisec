package domain

import (
	"context"
	"errors"
	"fmt"
	"log"
	"mime/multipart"
	"net/http"
	"os"
	"path/filepath"
	"time"

	"risknexus/backend/internal/dto"
	"risknexus/backend/internal/repo"

	"github.com/google/uuid"
)

type AssetService struct {
	assetRepo              AssetRepoInterface
	userRepo               UserRepoInterface
	documentStorageService DocumentStorageServiceInterface
}

func NewAssetService(assetRepo AssetRepoInterface, userRepo UserRepoInterface, documentStorageService DocumentStorageServiceInterface) *AssetService {
	return &AssetService{
		assetRepo:              assetRepo,
		userRepo:               userRepo,
		documentStorageService: documentStorageService,
	}
}

func (s *AssetService) CreateAsset(ctx context.Context, tenantID string, req dto.CreateAssetRequest, createdBy string) (*repo.Asset, error) {
	log.Printf("DEBUG: asset_service.CreateAsset tenant=%s name=%s", tenantID, req.Name)

	// Validate owner exists if provided
	if req.OwnerID != "" {
		owner, err := s.userRepo.GetByID(ctx, req.OwnerID)
		if err != nil {
			log.Printf("ERROR: asset_service.CreateAsset GetByID owner: %v", err)
			return nil, err
		}
		if owner == nil {
			log.Printf("WARN: asset_service.CreateAsset owner not found id=%s", req.OwnerID)
			return nil, errors.New("owner not found")
		}
	}

	// Validate responsible user exists if provided
	if req.ResponsibleUserID != "" {
		responsibleUser, err := s.userRepo.GetByID(ctx, req.ResponsibleUserID)
		if err != nil {
			log.Printf("ERROR: asset_service.CreateAsset GetByID responsible user: %v", err)
			return nil, err
		}
		if responsibleUser == nil {
			log.Printf("WARN: asset_service.CreateAsset responsible user not found id=%s", req.ResponsibleUserID)
			return nil, errors.New("responsible user not found")
		}
	}

	// Set default status if not provided
	status := req.Status
	if status == "" {
		status = "active"
	}

	// Create asset
	asset := repo.Asset{
		ID:                uuid.New().String(),
		TenantID:          tenantID,
		InventoryNumber:   "", // Will be generated by repo
		Name:              req.Name,
		Type:              req.Type,
		Class:             req.Class,
		OwnerID:           &req.OwnerID,
		ResponsibleUserID: &req.ResponsibleUserID,
		Location:          &req.Location,
		Criticality:       req.Criticality,
		Confidentiality:   req.Confidentiality,
		Integrity:         req.Integrity,
		Availability:      req.Availability,
		Status:            status,
		CreatedAt:         time.Now(),
		UpdatedAt:         time.Now(),
	}

	// Handle empty owner ID
	if req.OwnerID == "" {
		asset.OwnerID = nil
	}

	// Handle empty responsible user ID
	if req.ResponsibleUserID == "" {
		asset.ResponsibleUserID = nil
	}

	err := s.assetRepo.Create(ctx, asset)
	if err != nil {
		log.Printf("ERROR: asset_service.CreateAsset repo.Create: %v", err)
		return nil, err
	}

	// Log creation in history
	err = s.assetRepo.AddHistory(ctx, asset.ID, "created", "", "Asset created", createdBy)
	if err != nil {
		log.Printf("WARN: asset_service.CreateAsset AddHistory: %v", err)
	}

	log.Printf("DEBUG: asset_service.CreateAsset success id=%s", asset.ID)
	return &asset, nil
}

func (s *AssetService) GetAsset(ctx context.Context, id string) (*repo.Asset, error) {
	return s.assetRepo.GetByID(ctx, id)
}

func (s *AssetService) GetAssetWithDetails(ctx context.Context, id string) (*repo.AssetWithDetails, error) {
	return s.assetRepo.GetWithDetails(ctx, id)
}

func (s *AssetService) ListAssets(ctx context.Context, tenantID string, filters map[string]interface{}) ([]repo.Asset, error) {
	return s.assetRepo.List(ctx, tenantID, filters)
}

func (s *AssetService) ListAssetsPaginated(ctx context.Context, tenantID string, page, pageSize int, filters map[string]interface{}) ([]repo.Asset, int64, error) {
	return s.assetRepo.ListPaginated(ctx, tenantID, page, pageSize, filters)
}

func (s *AssetService) UpdateAsset(ctx context.Context, id string, req dto.UpdateAssetRequest, updatedBy string) error {
	log.Printf("DEBUG: asset_service.UpdateAsset id=%s", id)

	// Get existing asset
	asset, err := s.assetRepo.GetByID(ctx, id)
	if err != nil {
		log.Printf("ERROR: asset_service.UpdateAsset GetByID: %v", err)
		return err
	}
	if asset == nil {
		log.Printf("WARN: asset_service.UpdateAsset not found id=%s", id)
		return errors.New("asset not found")
	}

	// Check if asset is decommissioned - block most updates
	if asset.Status == "decommissioned" {
		// Only allow status changes from decommissioned
		if req.Status == nil || *req.Status == "decommissioned" {
			log.Printf("WARN: asset_service.UpdateAsset trying to update decommissioned asset id=%s", id)
			return errors.New("cannot update decommissioned asset")
		}
	}

	// Validate owner if provided
	if req.OwnerID != nil && *req.OwnerID != "" {
		owner, err := s.userRepo.GetByID(ctx, *req.OwnerID)
		if err != nil {
			log.Printf("ERROR: asset_service.UpdateAsset GetByID owner: %v", err)
			return err
		}
		if owner == nil {
			log.Printf("WARN: asset_service.UpdateAsset owner not found id=%s", *req.OwnerID)
			return errors.New("owner not found")
		}
	}

	// Validate responsible user if provided
	if req.ResponsibleUserID != nil && *req.ResponsibleUserID != "" {
		responsibleUser, err := s.userRepo.GetByID(ctx, *req.ResponsibleUserID)
		if err != nil {
			log.Printf("ERROR: asset_service.UpdateAsset GetByID responsible user: %v", err)
			return err
		}
		if responsibleUser == nil {
			log.Printf("WARN: asset_service.UpdateAsset responsible user not found id=%s", *req.ResponsibleUserID)
			return errors.New("responsible user not found")
		}
	}

	// Track changes for history
	changes := make(map[string]string)
	oldValues := make(map[string]string) // Сохраняем старые значения

	// Update fields if provided
	if req.Name != nil && *req.Name != asset.Name {
		oldValues["name"] = asset.Name // Сохраняем старое значение
		changes["name"] = *req.Name
		asset.Name = *req.Name
	}
	if req.Type != nil && *req.Type != asset.Type {
		oldValues["type"] = asset.Type
		changes["type"] = *req.Type
		asset.Type = *req.Type
	}
	if req.Class != nil && *req.Class != asset.Class {
		oldValues["class"] = asset.Class
		changes["class"] = *req.Class
		asset.Class = *req.Class
	}
	if req.OwnerID != nil {
		newOwnerID := ""
		if *req.OwnerID != "" {
			newOwnerID = *req.OwnerID
		}
		oldOwnerID := ""
		if asset.OwnerID != nil {
			oldOwnerID = *asset.OwnerID
		}
		if newOwnerID != oldOwnerID {
			oldValues["owner_id"] = oldOwnerID
			changes["owner_id"] = newOwnerID
			if newOwnerID == "" {
				asset.OwnerID = nil
			} else {
				asset.OwnerID = &newOwnerID
			}
		}
	}
	if req.ResponsibleUserID != nil {
		newResponsibleUserID := ""
		if *req.ResponsibleUserID != "" {
			newResponsibleUserID = *req.ResponsibleUserID
		}
		oldResponsibleUserID := ""
		if asset.ResponsibleUserID != nil {
			oldResponsibleUserID = *asset.ResponsibleUserID
		}
		if newResponsibleUserID != oldResponsibleUserID {
			oldValues["responsible_user_id"] = oldResponsibleUserID
			changes["responsible_user_id"] = newResponsibleUserID
			if newResponsibleUserID == "" {
				asset.ResponsibleUserID = nil
			} else {
				asset.ResponsibleUserID = &newResponsibleUserID
			}
		}
	}
	if req.Location != nil {
		newLocation := *req.Location
		oldLocation := ""
		if asset.Location != nil {
			oldLocation = *asset.Location
		}
		if newLocation != oldLocation {
			oldValues["location"] = oldLocation
			changes["location"] = newLocation
			asset.Location = &newLocation
		}
	}
	if req.Criticality != nil && *req.Criticality != asset.Criticality {
		oldValues["criticality"] = asset.Criticality
		changes["criticality"] = *req.Criticality
		asset.Criticality = *req.Criticality
	}
	if req.Confidentiality != nil && *req.Confidentiality != asset.Confidentiality {
		oldValues["confidentiality"] = asset.Confidentiality
		changes["confidentiality"] = *req.Confidentiality
		asset.Confidentiality = *req.Confidentiality
	}
	if req.Integrity != nil && *req.Integrity != asset.Integrity {
		oldValues["integrity"] = asset.Integrity
		changes["integrity"] = *req.Integrity
		asset.Integrity = *req.Integrity
	}
	if req.Availability != nil && *req.Availability != asset.Availability {
		oldValues["availability"] = asset.Availability
		changes["availability"] = *req.Availability
		asset.Availability = *req.Availability
	}
	if req.Status != nil && *req.Status != asset.Status {
		oldValues["status"] = asset.Status
		changes["status"] = *req.Status
		asset.Status = *req.Status
	}

	// Update asset if there are changes
	if len(changes) > 0 {
		asset.UpdatedAt = time.Now()
		err = s.assetRepo.Update(ctx, *asset)
		if err != nil {
			log.Printf("ERROR: asset_service.UpdateAsset repo.Update: %v", err)
			return err
		}

		// Log changes in history
		for field, newValue := range changes {
			oldValue := oldValues[field] // Используем сохраненное старое значение
			err = s.assetRepo.AddHistory(ctx, id, field, oldValue, newValue, updatedBy)
			if err != nil {
				log.Printf("WARN: asset_service.UpdateAsset AddHistory %s: %v", field, err)
			}
		}
	}

	return nil
}

func (s *AssetService) DeleteAsset(ctx context.Context, id string, deletedBy string) error {
	log.Printf("DEBUG: asset_service.DeleteAsset id=%s", id)

	// Check if asset exists
	asset, err := s.assetRepo.GetByID(ctx, id)
	if err != nil {
		log.Printf("ERROR: asset_service.DeleteAsset GetByID: %v", err)
		return err
	}
	if asset == nil {
		log.Printf("WARN: asset_service.DeleteAsset not found id=%s", id)
		return errors.New("asset not found")
	}

	// Soft delete
	err = s.assetRepo.SoftDelete(ctx, id)
	if err != nil {
		log.Printf("ERROR: asset_service.DeleteAsset repo.SoftDelete: %v", err)
		return err
	}

	// Log deletion in history
	err = s.assetRepo.AddHistory(ctx, id, "deleted", "", "Asset deleted", deletedBy)
	if err != nil {
		log.Printf("WARN: asset_service.DeleteAsset AddHistory: %v", err)
	}

	log.Printf("DEBUG: asset_service.DeleteAsset success id=%s", id)
	return nil
}

func (s *AssetService) AddDocument(ctx context.Context, assetID string, req dto.AssetDocumentRequest, createdBy string) error {
	log.Printf("DEBUG: asset_service.AddDocument assetID=%s type=%s", assetID, req.DocumentType)

	// Check if asset exists
	asset, err := s.assetRepo.GetByID(ctx, assetID)
	if err != nil {
		return err
	}
	if asset == nil {
		return errors.New("asset not found")
	}

	// Add document
	err = s.assetRepo.AddDocument(ctx, assetID, req.DocumentType, req.FilePath, createdBy)
	if err != nil {
		log.Printf("ERROR: asset_service.AddDocument repo.AddDocument: %v", err)
		return err
	}

	// Log in history
	err = s.assetRepo.AddHistory(ctx, assetID, "document_added", "", req.DocumentType, createdBy)
	if err != nil {
		log.Printf("WARN: asset_service.AddDocument AddHistory: %v", err)
	}

	return nil
}

func (s *AssetService) GetAssetDocuments(ctx context.Context, assetID string) ([]repo.AssetDocument, error) {
	return s.assetRepo.GetAssetDocuments(ctx, assetID)
}

// UploadDocument uploads a new document file to an asset
func (s *AssetService) UploadDocument(ctx context.Context, assetID string, req dto.AssetDocumentUploadRequest, createdBy, tenantID string) (*dto.AssetDocumentResponse, error) {
	log.Printf("DEBUG: asset_service.UploadDocument assetID=%s type=%s", assetID, req.DocumentType)

	// Check if asset exists
	asset, err := s.assetRepo.GetByID(ctx, assetID)
	if err != nil {
		return nil, err
	}
	if asset == nil {
		return nil, errors.New("asset not found")
	}

	// Generate unique filename
	fileID := uuid.New().String()
	fileName := fileID
	if req.Title != "" {
		fileName = fmt.Sprintf("%s_%s", fileID, req.Title)
	}

	// Create upload directory
	uploadDir := fmt.Sprintf("./uploads/%s/assets/%s", tenantID, assetID)
	err = os.MkdirAll(uploadDir, 0755)
	if err != nil {
		log.Printf("ERROR: asset_service.UploadDocument MkdirAll: %v", err)
		return nil, err
	}

	// Save file
	filePath := filepath.Join(uploadDir, fileName)
	err = os.WriteFile(filePath, req.File, 0644)
	if err != nil {
		log.Printf("ERROR: asset_service.UploadDocument WriteFile: %v", err)
		return nil, err
	}

	// Detect MIME type
	mimeType := http.DetectContentType(req.File)

	// Add document to database
	documentID := uuid.New().String()
	err = s.assetRepo.AddDocumentWithFile(ctx, assetID, documentID, req.DocumentType, filePath, fileName, mimeType, int64(len(req.File)), createdBy)
	if err != nil {
		log.Printf("ERROR: asset_service.UploadDocument repo.AddDocumentWithFile: %v", err)
		// Clean up file
		os.Remove(filePath)
		return nil, err
	}

	// Log in history
	err = s.assetRepo.AddHistory(ctx, assetID, "document_uploaded", "", req.DocumentType, createdBy)
	if err != nil {
		log.Printf("WARN: asset_service.UploadDocument AddHistory: %v", err)
	}

	// Return response
	response := &dto.AssetDocumentResponse{
		ID:           documentID,
		AssetID:      assetID,
		Title:        req.Title,
		DocumentType: req.DocumentType,
		Mime:         mimeType,
		SizeBytes:    int64(len(req.File)),
		DownloadURL:  fmt.Sprintf("/api/v1/assets/documents/%s/download", documentID),
		CreatedBy:    createdBy,
		CreatedAt:    time.Now(),
	}

	log.Printf("DEBUG: asset_service.UploadDocument success id=%s", documentID)
	return response, nil
}

// LinkDocument links an existing document to an asset
func (s *AssetService) LinkDocument(ctx context.Context, assetID string, req dto.AssetDocumentLinkRequest, createdBy string) (*dto.AssetDocumentResponse, error) {
	log.Printf("DEBUG: asset_service.LinkDocument assetID=%s docID=%s", assetID, req.DocumentID)

	// Check if asset exists
	asset, err := s.assetRepo.GetByID(ctx, assetID)
	if err != nil {
		return nil, err
	}
	if asset == nil {
		return nil, errors.New("asset not found")
	}

	// Get document from storage
	doc, err := s.assetRepo.GetDocumentFromStorage(ctx, req.DocumentID)
	if err != nil {
		return nil, err
	}
	if doc == nil {
		return nil, errors.New("document not found in storage")
	}

	// Link document to asset
	documentID := uuid.New().String()
	err = s.assetRepo.LinkDocumentToAsset(ctx, assetID, documentID, req.DocumentID, req.DocumentType, createdBy)
	if err != nil {
		log.Printf("ERROR: asset_service.LinkDocument repo.LinkDocumentToAsset: %v", err)
		return nil, err
	}

	// Log in history
	err = s.assetRepo.AddHistory(ctx, assetID, "document_linked", "", req.DocumentType, createdBy)
	if err != nil {
		log.Printf("WARN: asset_service.LinkDocument AddHistory: %v", err)
	}

	// Return response
	response := &dto.AssetDocumentResponse{
		ID:           documentID,
		AssetID:      assetID,
		Title:        doc.Title,
		DocumentType: req.DocumentType,
		Mime:         doc.Mime,
		SizeBytes:    doc.SizeBytes,
		DownloadURL:  fmt.Sprintf("/api/v1/assets/documents/%s/download", documentID),
		CreatedBy:    createdBy,
		CreatedAt:    time.Now(),
	}

	log.Printf("DEBUG: asset_service.LinkDocument success id=%s", documentID)
	return response, nil
}

// GetDocumentDownloadPath returns the file path for downloading a document
func (s *AssetService) GetDocumentDownloadPath(ctx context.Context, documentID, userID string) (string, string, error) {
	doc, err := s.assetRepo.GetDocumentByID(ctx, documentID)
	if err != nil {
		return "", "", err
	}
	if doc == nil {
		return "", "", errors.New("document not found")
	}

	// Extract filename from file path
	fileName := filepath.Base(doc.FilePath)
	return doc.FilePath, fileName, nil
}

// GetDocumentStorage returns documents from storage with pagination and filtering
func (s *AssetService) GetDocumentStorage(ctx context.Context, tenantID string, req dto.DocumentStorageRequest) ([]dto.DocumentStorageResponse, int64, error) {
	return s.assetRepo.GetDocumentStorage(ctx, tenantID, req)
}

func (s *AssetService) AddSoftware(ctx context.Context, assetID string, req dto.AssetSoftwareRequest, addedBy string) error {
	log.Printf("DEBUG: asset_service.AddSoftware assetID=%s name=%s", assetID, req.SoftwareName)

	// Check if asset exists
	asset, err := s.assetRepo.GetByID(ctx, assetID)
	if err != nil {
		return err
	}
	if asset == nil {
		return errors.New("asset not found")
	}

	// Add software
	version := ""
	if req.Version != nil {
		version = *req.Version
	}
	err = s.assetRepo.AddSoftware(ctx, assetID, req.SoftwareName, version, req.InstalledAt)
	if err != nil {
		log.Printf("ERROR: asset_service.AddSoftware repo.AddSoftware: %v", err)
		return err
	}

	// Log in history
	err = s.assetRepo.AddHistory(ctx, assetID, "software_added", "", req.SoftwareName, addedBy)
	if err != nil {
		log.Printf("WARN: asset_service.AddSoftware AddHistory: %v", err)
	}

	return nil
}

func (s *AssetService) GetAssetSoftware(ctx context.Context, assetID string) ([]repo.AssetSoftware, error) {
	return s.assetRepo.GetAssetSoftware(ctx, assetID)
}

func (s *AssetService) GetAssetHistory(ctx context.Context, assetID string) ([]repo.AssetHistory, error) {
	return s.assetRepo.GetAssetHistory(ctx, assetID)
}

func (s *AssetService) GetAssetHistoryWithFilters(ctx context.Context, assetID string, filters map[string]interface{}) ([]repo.AssetHistory, error) {
	return s.assetRepo.GetAssetHistoryWithFilters(ctx, assetID, filters)
}

func (s *AssetService) DeleteDocument(ctx context.Context, documentID string, deletedBy string) error {
	log.Printf("DEBUG: asset_service.DeleteDocument documentID=%s", documentID)

	// Get document to check if it exists
	doc, err := s.assetRepo.GetDocumentByID(ctx, documentID)
	if err != nil {
		log.Printf("ERROR: asset_service.DeleteDocument GetDocumentByID: %v", err)
		return err
	}
	if doc == nil {
		log.Printf("WARN: asset_service.DeleteDocument not found id=%s", documentID)
		return errors.New("document not found")
	}

	// Delete document
	err = s.assetRepo.DeleteDocument(ctx, documentID)
	if err != nil {
		log.Printf("ERROR: asset_service.DeleteDocument repo.DeleteDocument: %v", err)
		return err
	}

	// Log deletion in history
	err = s.assetRepo.AddHistory(ctx, doc.AssetID, "document_deleted", doc.DocumentType, "Document deleted", deletedBy)
	if err != nil {
		log.Printf("WARN: asset_service.DeleteDocument AddHistory: %v", err)
	}

	log.Printf("DEBUG: asset_service.DeleteDocument success id=%s", documentID)
	return nil
}

func (s *AssetService) GetDocumentByID(ctx context.Context, documentID string) (*repo.AssetDocument, error) {
	return s.assetRepo.GetDocumentByID(ctx, documentID)
}

func (s *AssetService) GetAssetRisks(ctx context.Context, assetID string) ([]repo.Risk, error) {
	return s.assetRepo.GetAssetRisks(ctx, assetID)
}

func (s *AssetService) GetAssetIncidents(ctx context.Context, assetID string) ([]repo.Incident, error) {
	return s.assetRepo.GetAssetIncidents(ctx, assetID)
}

// CanAddRisk checks if a risk can be added to an asset
func (s *AssetService) CanAddRisk(ctx context.Context, assetID string) error {
	asset, err := s.assetRepo.GetByID(ctx, assetID)
	if err != nil {
		return err
	}
	if asset == nil {
		return errors.New("asset not found")
	}
	if asset.Status == "decommissioned" {
		return errors.New("cannot add risk to decommissioned asset")
	}
	return nil
}

// CanAddIncident checks if an incident can be added to an asset
func (s *AssetService) CanAddIncident(ctx context.Context, assetID string) error {
	asset, err := s.assetRepo.GetByID(ctx, assetID)
	if err != nil {
		return err
	}
	if asset == nil {
		return errors.New("asset not found")
	}
	if asset.Status == "decommissioned" {
		return errors.New("cannot add incident to decommissioned asset")
	}
	return nil
}

func (s *AssetService) GetAssetsWithoutOwner(ctx context.Context, tenantID string) ([]repo.Asset, error) {
	return s.assetRepo.GetAssetsWithoutOwner(ctx, tenantID)
}

func (s *AssetService) GetAssetsWithoutPassport(ctx context.Context, tenantID string) ([]repo.Asset, error) {
	return s.assetRepo.GetAssetsWithoutPassport(ctx, tenantID)
}

func (s *AssetService) GetAssetsWithoutCriticality(ctx context.Context, tenantID string) ([]repo.Asset, error) {
	return s.assetRepo.GetAssetsWithoutCriticality(ctx, tenantID)
}

// BulkUpdateStatus updates status for multiple assets
func (s *AssetService) BulkUpdateStatus(ctx context.Context, assetIDs []string, newStatus string, updatedBy string) error {
	log.Printf("DEBUG: asset_service.BulkUpdateStatus assetIDs=%v status=%s", assetIDs, newStatus)

	// Validate all assets exist and belong to the same tenant
	for _, assetID := range assetIDs {
		asset, err := s.assetRepo.GetByID(ctx, assetID)
		if err != nil {
			log.Printf("ERROR: asset_service.BulkUpdateStatus GetByID %s: %v", assetID, err)
			return err
		}
		if asset == nil {
			log.Printf("WARN: asset_service.BulkUpdateStatus not found id=%s", assetID)
			return errors.New("asset not found: " + assetID)
		}
	}

	// Update each asset
	for _, assetID := range assetIDs {
		updateReq := dto.UpdateAssetRequest{
			Status: &newStatus,
		}
		err := s.UpdateAsset(ctx, assetID, updateReq, updatedBy)
		if err != nil {
			log.Printf("ERROR: asset_service.BulkUpdateStatus UpdateAsset %s: %v", assetID, err)
			return err
		}
	}

	log.Printf("DEBUG: asset_service.BulkUpdateStatus success")
	return nil
}

// BulkUpdateOwner updates owner for multiple assets
func (s *AssetService) BulkUpdateOwner(ctx context.Context, assetIDs []string, newOwnerID string, updatedBy string) error {
	log.Printf("DEBUG: asset_service.BulkUpdateOwner assetIDs=%v owner=%s", assetIDs, newOwnerID)

	// Validate owner exists if provided
	if newOwnerID != "" {
		owner, err := s.userRepo.GetByID(ctx, newOwnerID)
		if err != nil {
			log.Printf("ERROR: asset_service.BulkUpdateOwner GetByID owner: %v", err)
			return err
		}
		if owner == nil {
			log.Printf("WARN: asset_service.BulkUpdateOwner owner not found id=%s", newOwnerID)
			return errors.New("owner not found")
		}
	}

	// Validate all assets exist
	for _, assetID := range assetIDs {
		asset, err := s.assetRepo.GetByID(ctx, assetID)
		if err != nil {
			log.Printf("ERROR: asset_service.BulkUpdateOwner GetByID %s: %v", assetID, err)
			return err
		}
		if asset == nil {
			log.Printf("WARN: asset_service.BulkUpdateOwner not found id=%s", assetID)
			return errors.New("asset not found: " + assetID)
		}
	}

	// Update each asset
	for _, assetID := range assetIDs {
		updateReq := dto.UpdateAssetRequest{
			OwnerID: &newOwnerID,
		}
		err := s.UpdateAsset(ctx, assetID, updateReq, updatedBy)
		if err != nil {
			log.Printf("ERROR: asset_service.BulkUpdateOwner UpdateAsset %s: %v", assetID, err)
			return err
		}
	}

	log.Printf("DEBUG: asset_service.BulkUpdateOwner success")
	return nil
}

func (s *AssetService) PerformInventory(ctx context.Context, tenantID string, req dto.AssetInventoryRequest, performedBy string) error {
	log.Printf("DEBUG: asset_service.PerformInventory tenant=%s action=%s", tenantID, req.Action)

	// Validate all assets exist
	for _, assetID := range req.AssetIDs {
		asset, err := s.assetRepo.GetByID(ctx, assetID)
		if err != nil {
			return err
		}
		if asset == nil {
			return errors.New("asset not found: " + assetID)
		}
	}

	// Perform inventory action
	for _, assetID := range req.AssetIDs {
		if req.Action == "update_status" && req.Status != nil {
			// Update status
			updateReq := dto.UpdateAssetRequest{
				Status: req.Status,
			}
			err := s.UpdateAsset(ctx, assetID, updateReq, performedBy)
			if err != nil {
				log.Printf("ERROR: asset_service.PerformInventory UpdateAsset %s: %v", assetID, err)
				return err
			}
		}

		// Log inventory action
		action := "inventory_" + req.Action
		notes := ""
		if req.Notes != nil {
			notes = *req.Notes
		}
		err := s.assetRepo.AddHistory(ctx, assetID, action, "", notes, performedBy)
		if err != nil {
			log.Printf("WARN: asset_service.PerformInventory AddHistory %s: %v", assetID, err)
		}
	}

	log.Printf("DEBUG: asset_service.PerformInventory success")
	return nil
}

// UploadAssetDocument загружает документ в централизованное хранилище и связывает с активом
func (s *AssetService) UploadAssetDocument(ctx context.Context, assetID, tenantID string, file multipart.File, header *multipart.FileHeader, req dto.AssetDocumentUploadRequest, createdBy string) (*dto.DocumentDTO, error) {
	log.Printf("DEBUG: asset_service.UploadAssetDocument assetID=%s type=%s", assetID, req.DocumentType)

	// Проверяем, что актив существует
	asset, err := s.assetRepo.GetByID(ctx, assetID)
	if err != nil {
		return nil, err
	}
	if asset == nil {
		return nil, errors.New("asset not found")
	}

	// Создаем запрос для загрузки в централизованное хранилище
	uploadReq := dto.UploadDocumentDTO{
		Name:        req.Title,
		Description: assetStringPtr(fmt.Sprintf("Document for asset %s (%s)", asset.Name, asset.InventoryNumber)),
		FolderID:    nil, // Можно создать папку для документов активов
		Tags:        []string{"#активы", fmt.Sprintf("#%s", req.DocumentType)},
		LinkedTo: &dto.DocumentLinkDTO{
			Module:   "assets",
			EntityID: assetID,
		},
		Metadata: assetStringPtr(fmt.Sprintf(`{"asset_id": "%s", "asset_name": "%s", "document_type": "%s"}`, assetID, asset.Name, req.DocumentType)),
	}

	// Загружаем документ в централизованное хранилище
	document, err := s.documentStorageService.UploadDocument(ctx, tenantID, file, header, uploadReq, createdBy)
	if err != nil {
		log.Printf("ERROR: asset_service.UploadAssetDocument UploadDocument: %v", err)
		return nil, err
	}

	// Логируем в историю актива
	err = s.assetRepo.AddHistory(ctx, assetID, "document_uploaded", "", fmt.Sprintf("Document uploaded: %s", document.Title), createdBy)
	if err != nil {
		log.Printf("WARN: asset_service.UploadAssetDocument AddHistory: %v", err)
	}

	log.Printf("DEBUG: asset_service.UploadAssetDocument success documentID=%s", document.ID)
	return document, nil
}

// GetAssetDocumentsFromStorage получает документы, связанные с активом из централизованного хранилища
func (s *AssetService) GetAssetDocumentsFromStorage(ctx context.Context, assetID, tenantID string) ([]dto.DocumentDTO, error) {
	log.Printf("DEBUG: asset_service.GetAssetDocumentsFromStorage assetID=%s tenantID=%s", assetID, tenantID)

	// Проверяем, что актив существует
	asset, err := s.assetRepo.GetByID(ctx, assetID)
	if err != nil {
		return nil, err
	}
	if asset == nil {
		return nil, errors.New("asset not found")
	}

	// Получаем документы из централизованного хранилища
	documents, err := s.documentStorageService.GetModuleDocuments(ctx, "assets", assetID, tenantID)
	if err != nil {
		log.Printf("ERROR: asset_service.GetAssetDocumentsFromStorage GetModuleDocuments: %v", err)
		return nil, err
	}

	log.Printf("DEBUG: asset_service.GetAssetDocumentsFromStorage found %d documents for assetID=%s", len(documents), assetID)
	return documents, nil
}

// LinkExistingDocumentToAsset связывает существующий документ с активом
func (s *AssetService) LinkExistingDocumentToAsset(ctx context.Context, assetID, documentID, tenantID, linkedBy string) error {
	log.Printf("DEBUG: asset_service.LinkExistingDocumentToAsset assetID=%s documentID=%s", assetID, documentID)

	// Проверяем, что актив существует
	asset, err := s.assetRepo.GetByID(ctx, assetID)
	if err != nil {
		return err
	}
	if asset == nil {
		return errors.New("asset not found")
	}

	// Проверяем, что документ существует
	document, err := s.documentStorageService.GetDocument(ctx, documentID, tenantID)
	if err != nil {
		return err
	}

	// Связываем документ с активом
	err = s.documentStorageService.LinkDocumentToModule(ctx, documentID, "assets", assetID, "attachment", fmt.Sprintf("Linked to asset %s", asset.Name), linkedBy)
	if err != nil {
		log.Printf("ERROR: asset_service.LinkExistingDocumentToAsset LinkDocumentToModule: %v", err)
		return err
	}

	// Логируем в историю актива
	err = s.assetRepo.AddHistory(ctx, assetID, "document_linked", "", fmt.Sprintf("Document linked: %s", document.Title), linkedBy)
	if err != nil {
		log.Printf("WARN: asset_service.LinkExistingDocumentToAsset AddHistory: %v", err)
	}

	log.Printf("DEBUG: asset_service.LinkExistingDocumentToAsset success")
	return nil
}

// UnlinkDocumentFromAsset отвязывает документ от актива
func (s *AssetService) UnlinkDocumentFromAsset(ctx context.Context, assetID, documentID, tenantID, unlinkedBy string) error {
	log.Printf("DEBUG: asset_service.UnlinkDocumentFromAsset assetID=%s documentID=%s", assetID, documentID)

	// Проверяем, что актив существует
	asset, err := s.assetRepo.GetByID(ctx, assetID)
	if err != nil {
		return err
	}
	if asset == nil {
		return errors.New("asset not found")
	}

	// Получаем информацию о документе
	document, err := s.documentStorageService.GetDocument(ctx, documentID, tenantID)
	if err != nil {
		return err
	}

	// Отвязываем документ от актива
	err = s.documentStorageService.UnlinkDocumentFromModule(ctx, documentID, "assets", assetID, unlinkedBy)
	if err != nil {
		log.Printf("ERROR: asset_service.UnlinkDocumentFromAsset UnlinkDocumentFromModule: %v", err)
		return err
	}

	// Логируем в историю актива
	err = s.assetRepo.AddHistory(ctx, assetID, "document_unlinked", "", fmt.Sprintf("Document unlinked: %s", document.Title), unlinkedBy)
	if err != nil {
		log.Printf("WARN: asset_service.UnlinkDocumentFromAsset AddHistory: %v", err)
	}

	log.Printf("DEBUG: asset_service.UnlinkDocumentFromAsset success")
	return nil
}

// DeleteAssetDocument удаляет документ из централизованного хранилища
func (s *AssetService) DeleteAssetDocument(ctx context.Context, assetID, documentID, tenantID, deletedBy string) error {
	log.Printf("DEBUG: asset_service.DeleteAssetDocument assetID=%s documentID=%s", assetID, documentID)

	// Проверяем, что актив существует
	asset, err := s.assetRepo.GetByID(ctx, assetID)
	if err != nil {
		return err
	}
	if asset == nil {
		return errors.New("asset not found")
	}

	// Получаем информацию о документе
	document, err := s.documentStorageService.GetDocument(ctx, documentID, tenantID)
	if err != nil {
		return err
	}

	// Удаляем документ из централизованного хранилища
	err = s.documentStorageService.DeleteDocument(ctx, documentID, tenantID, deletedBy)
	if err != nil {
		log.Printf("ERROR: asset_service.DeleteAssetDocument DeleteDocument: %v", err)
		return err
	}

	// Логируем в историю актива
	err = s.assetRepo.AddHistory(ctx, assetID, "document_deleted", "", fmt.Sprintf("Document deleted: %s", document.Title), deletedBy)
	if err != nil {
		log.Printf("WARN: asset_service.DeleteAssetDocument AddHistory: %v", err)
	}

	log.Printf("DEBUG: asset_service.DeleteAssetDocument success")
	return nil
}

// DeleteDocumentLink удаляет ВСЕ связи документа с модулем "assets"
func (s *AssetService) DeleteDocumentLink(ctx context.Context, documentID, tenantID, deletedBy string) error {
	log.Printf("DEBUG: asset_service.DeleteDocumentLink documentID=%s", documentID)

	// Получаем информацию о документе
	document, err := s.documentStorageService.GetDocument(ctx, documentID, tenantID)
	if err != nil {
		return err
	}

	// Удаляем ВСЕ связи этого документа с модулем "assets"
	// Это удалит связь с ЛЮБЫМ активом, к которому привязан этот документ
	err = s.documentStorageService.UnlinkDocumentFromModule(ctx, documentID, "assets", "", deletedBy)
	if err != nil {
		log.Printf("ERROR: asset_service.DeleteDocumentLink UnlinkDocumentFromModule: %v", err)
		return err
	}

	log.Printf("DEBUG: asset_service.DeleteDocumentLink success - unlinked document '%s' from all assets", document.Title)
	return nil
}

// Helper function to create string pointer
func assetStringPtr(s string) *string {
	return &s
}
