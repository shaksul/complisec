Документация модуля «Риски»
1. Назначение модуля

Модуль предназначен для централизованного управления рисками информационной безопасности и смежных бизнес-процессов. Обеспечивает сбор, классификацию, анализ, оценку и мониторинг рисков, а также формирование отчетности и контроль реализации мер по их снижению.

2. Основные функции

Реестр рисков

Создание, редактирование и удаление карточек риска.

Привязка риска к активам, процессам, инцидентам и пользователям.

Назначение ответственного владельца риска.

Поддержка статусов (новый, в анализе, в обработке, закрыт).

Классификация

Категории: операционные, технические, организационные, регуляторные.

Влияние: финансовое, репутационное, правовое, технологическое.

Источники: внешние, внутренние.

Оценка рисков

Поле для указания вероятности наступления (низкая, средняя, высокая).

Поле для указания уровня ущерба/влияния.

Автоматический расчет итогового уровня риска (матрица риска).

Возможность использовать разные методики (ISO 27005, NIST, COSO, внутренние).

Обработка рисков

Стратегии: принять, снизить, передать, избежать.

Привязка мер/контролей (из раздела «Соответствие» или «Активы»).

Отслеживание сроков реализации мер.

Мониторинг

Дашборды с актуальными уровнями рисков.

История изменений по каждому риску.

Автоматические уведомления при повышении уровня риска.

Отчетность

Формирование отчетов по статусам рисков, владельцам, категориям.

Экспорт в PDF/Excel.

Визуализация (heatmap матрицы рисков).

3. Структура данных (карточка риска)

ID риска (генерируется системой)

Название риска

Описание риска

Категория

Источник риска

Актив/процесс (связь с модулем «Активы»)

Вероятность (низкая/средняя/высокая или числовая шкала)

Ущерб (низкий/средний/высокий или числовая шкала)

Итоговый уровень риска (автоматический расчет)

Методика оценки (ISO, NIST и т.п.)

Владелец риска (связь с пользователем)

Статус (новый, в обработке, закрыт и т.п.)

Меры воздействия (связь с контролями/политиками)

Сроки обработки

Журнал изменений (кто и когда изменил данные)

4. Роли и права

Администратор

Полный доступ (создание категорий, методик, назначение владельцев).

Аналитик рисков

Создание и оценка рисков, формирование отчетов.

Владелец риска

Просмотр и управление назначенными рисками, фиксация выполнения мер.

Аудитор

Доступ только для просмотра и выгрузки отчетов.

5. Бизнес-логика

При создании риска автоматически назначается статус "Новый" и владелец.

При изменении вероятности или ущерба система пересчитывает итоговый уровень риска.

Если уровень риска ≥ заданного порога → система отправляет уведомление владельцу и администратору.

При закрытии риска в журнал автоматически фиксируется дата и причина.

Риски можно связывать с инцидентами для анализа причин.

6. Интерфейс

Главная страница раздела «Риски»:

Таблица с фильтрацией (по статусу, категории, владельцу).

Возможность поиска по ключевым словам.

Кнопка «Добавить риск».

Карточка риска:

Поля с данными.

История изменений.

Вкладка «Меры воздействия».

Визуализация:

Матрица риска (heatmap).

Графики распределения по категориям и статусам.

7. Интеграции

С модулем «Активы» — привязка рисков к активам.

С модулем «Инциденты» — связь инцидентов с рисками.

С модулем «Соответствие» — контроль выполнения мер.

С модулем «Аудит» — автоматическая фиксация действий.

Хочешь, я сразу соберу структуру API и модели БД для раздела «Риски», чтобы курсору можно было передать полный набор?

Вы сказали:
да 
ChatGPT сказал:
Думал

Отлично. Ниже — полный пакет для реализации модуля «Риски»: схема БД (PostgreSQL), миграции, модели/DTO под Go (Fiber), права/ролевая модель, и OpenAPI-спека с примерами. Это можно сразу отдавать курсору.

Архитектура модуля «Риски»
1) Схема БД (PostgreSQL, multi-tenant)
-- 01_risk_enums.sql
CREATE TYPE risk_status AS ENUM ('new','in_analysis','in_treatment','accepted','transferred','mitigated','closed');
CREATE TYPE risk_probability AS ENUM ('low','medium','high','very_high');
CREATE TYPE risk_impact AS ENUM ('low','medium','high','critical');
CREATE TYPE risk_strategy AS ENUM ('accept','mitigate','transfer','avoid');

-- 02_risks_core.sql
CREATE TABLE risks (
  id               UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id        UUID NOT NULL,
  code             TEXT UNIQUE,                        -- например RNX-RSK-000123
  title            TEXT NOT NULL,
  description      TEXT,
  category         TEXT,                               -- свободная/справочник
  source           TEXT,                               -- внешний/внутренний/прочее
  asset_id         UUID,                               -- связь с активом (nullable)
  process_id       UUID,                               -- бизнес-процесс (nullable)
  incident_id      UUID,                               -- связанный инцидент (nullable)
  owner_user_id    UUID NOT NULL,                      -- владелец риска
  status           risk_status NOT NULL DEFAULT 'new',
  methodology      TEXT DEFAULT 'ISO27005',
  probability      risk_probability NOT NULL DEFAULT 'low',
  impact           risk_impact NOT NULL DEFAULT 'low',
  risk_score       INTEGER NOT NULL DEFAULT 1,         -- 1..16 (например 4x4)
  risk_level       TEXT GENERATED ALWAYS AS (
                     CASE
                       WHEN risk_score >= 12 THEN 'High'
                       WHEN risk_score >= 6  THEN 'Medium'
                       ELSE 'Low'
                     END
                   ) STORED,
  strategy         risk_strategy,
  due_date         DATE,
  created_by       UUID NOT NULL,
  updated_by       UUID,
  created_at       TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at       TIMESTAMPTZ NOT NULL DEFAULT now(),
  closed_at        TIMESTAMPTZ,
  close_reason     TEXT,
  CONSTRAINT risks_tenant_fk       FOREIGN KEY (tenant_id) REFERENCES tenants(id) ON DELETE CASCADE,
  CONSTRAINT risks_owner_fk        FOREIGN KEY (owner_user_id) REFERENCES users(id),
  CONSTRAINT risks_asset_fk        FOREIGN KEY (asset_id) REFERENCES assets(id),
  CONSTRAINT risks_process_fk      FOREIGN KEY (process_id) REFERENCES processes(id),
  CONSTRAINT risks_incident_fk     FOREIGN KEY (incident_id) REFERENCES incidents(id)
);

CREATE INDEX idx_risks_tenant ON risks(tenant_id);
CREATE INDEX idx_risks_status ON risks(tenant_id, status);
CREATE INDEX idx_risks_owner  ON risks(tenant_id, owner_user_id);
CREATE INDEX idx_risks_level  ON risks(tenant_id, risk_level);

-- 03_risk_controls_links.sql (связь с контролями/мерами)
CREATE TABLE risk_controls (
  id            UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id     UUID NOT NULL,
  risk_id       UUID NOT NULL,
  control_id    UUID NOT NULL,           -- ссылка на controls(id)
  planned_date  DATE,
  implemented   BOOLEAN NOT NULL DEFAULT FALSE,
  effectiveness INTEGER CHECK (effectiveness BETWEEN 0 AND 100),
  created_at    TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at    TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE (tenant_id, risk_id, control_id),
  FOREIGN KEY (risk_id) REFERENCES risks(id) ON DELETE CASCADE
);

-- 04_risk_history_audit.sql
CREATE TABLE risk_history (
  id            UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id     UUID NOT NULL,
  risk_id       UUID NOT NULL,
  changed_by    UUID NOT NULL,
  change_type   TEXT NOT NULL,           -- status_change, field_update, link_added и т.д.
  from_value    JSONB,
  to_value      JSONB,
  created_at    TIMESTAMPTZ NOT NULL DEFAULT now(),
  FOREIGN KEY (risk_id) REFERENCES risks(id) ON DELETE CASCADE
);
CREATE INDEX idx_risk_history_risk ON risk_history(risk_id, created_at DESC);

-- 05_risk_comments.sql
CREATE TABLE risk_comments (
  id         UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id  UUID NOT NULL,
  risk_id    UUID NOT NULL,
  author_id  UUID NOT NULL,
  body       TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  FOREIGN KEY (risk_id) REFERENCES risks(id) ON DELETE CASCADE
);

-- 06_risk_tags.sql (простые теги)
CREATE TABLE risk_tags (
  id         UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id  UUID NOT NULL,
  name       TEXT NOT NULL,
  UNIQUE (tenant_id, name)
);

CREATE TABLE risk_tag_map (
  risk_id UUID NOT NULL REFERENCES risks(id) ON DELETE CASCADE,
  tag_id  UUID NOT NULL REFERENCES risk_tags(id) ON DELETE CASCADE,
  PRIMARY KEY (risk_id, tag_id)
);

-- 07_risk_attachments.sql (если общий модуль вложений отсутствует)
CREATE TABLE risk_attachments (
  id           UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id    UUID NOT NULL,
  risk_id      UUID NOT NULL REFERENCES risks(id) ON DELETE CASCADE,
  file_name    TEXT NOT NULL,
  file_path    TEXT NOT NULL,         -- путь/ключ в объектном хранилище
  content_type TEXT,
  size_bytes   BIGINT,
  uploaded_by  UUID NOT NULL,
  created_at   TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- 08_triggers.sql (автообновление updated_at)
CREATE OR REPLACE FUNCTION set_updated_at() RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END; $$ LANGUAGE plpgsql;

CREATE TRIGGER trg_risks_updated
BEFORE UPDATE ON risks
FOR EACH ROW EXECUTE FUNCTION set_updated_at();

CREATE TRIGGER trg_risk_controls_updated
BEFORE UPDATE ON risk_controls
FOR EACH ROW EXECUTE FUNCTION set_updated_at();

Расчет risk_score

По умолчанию 4×4: probability × impact через числовое отображение:

probability: low=1, medium=2, high=3, very_high=4

impact: low=1, medium=2, high=3, critical=4

Сервисный слой может пересчитать и записать целое значение (1..16).

2) Роли и права (динамические)

Рекомендуемые права:

risk.read

risk.create

risk.update

risk.delete

risk.comment

risk.link.controls

risk.export

risk.admin (управление справочниками/методиками)

Роли-по-умолчанию (могут конфигурироваться через ваш модуль RBAC):

Администратор ИБ: все перечисленные.

Аналитик рисков: risk.read, risk.create, risk.update, risk.comment, risk.link.controls, risk.export.

Владелец риска: risk.read (свои), risk.update (поля статуса/сроков/исполнения), risk.comment.

Аудитор: risk.read, risk.export.

Фильтрация по арендаторам: все запросы требуют tenant_id из контекста (JWT/мидлварь).

3) Go: модели/DTO/валидаторы
Доменные модели (пример без ORM; при желании легко адаптируется под GORM/sqlc)
// apps/backend/internal/domain/risk.go
package domain

import (
	"time"
)

type RiskStatus string
const (
	RiskNew         RiskStatus = "new"
	RiskInAnalysis  RiskStatus = "in_analysis"
	RiskInTreatment RiskStatus = "in_treatment"
	RiskAccepted    RiskStatus = "accepted"
	RiskTransferred RiskStatus = "transferred"
	RiskMitigated   RiskStatus = "mitigated"
	RiskClosed      RiskStatus = "closed"
)

type RiskProbability string
const (
	ProbLow      RiskProbability = "low"
	ProbMedium   RiskProbability = "medium"
	ProbHigh     RiskProbability = "high"
	ProbVeryHigh RiskProbability = "very_high"
)

type RiskImpact string
const (
	ImpactLow      RiskImpact = "low"
	ImpactMedium   RiskImpact = "medium"
	ImpactHigh     RiskImpact = "high"
	ImpactCritical RiskImpact = "critical"
)

type RiskStrategy string
const (
	StratAccept   RiskStrategy = "accept"
	StratMitigate RiskStrategy = "mitigate"
	StratTransfer RiskStrategy = "transfer"
	StratAvoid    RiskStrategy = "avoid"
)

type Risk struct {
	ID            string          `json:"id"`
	TenantID      string          `json:"tenant_id"`
	Code          *string         `json:"code,omitempty"`
	Title         string          `json:"title"`
	Description   *string         `json:"description,omitempty"`
	Category      *string         `json:"category,omitempty"`
	Source        *string         `json:"source,omitempty"`
	AssetID       *string         `json:"asset_id,omitempty"`
	ProcessID     *string         `json:"process_id,omitempty"`
	IncidentID    *string         `json:"incident_id,omitempty"`
	OwnerUserID   string          `json:"owner_user_id"`
	Status        RiskStatus      `json:"status"`
	Methodology   string          `json:"methodology"`
	Probability   RiskProbability `json:"probability"`
	Impact        RiskImpact      `json:"impact"`
	RiskScore     int             `json:"risk_score"`
	RiskLevel     string          `json:"risk_level"`
	Strategy      *RiskStrategy   `json:"strategy,omitempty"`
	DueDate       *time.Time      `json:"due_date,omitempty"`
	CreatedBy     string          `json:"created_by"`
	UpdatedBy     *string         `json:"updated_by,omitempty"`
	CreatedAt     time.Time       `json:"created_at"`
	UpdatedAt     time.Time       `json:"updated_at"`
	ClosedAt      *time.Time      `json:"closed_at,omitempty"`
	CloseReason   *string         `json:"close_reason,omitempty"`
}

DTO/валидаторы
// apps/backend/internal/dto/risk_dto.go
package dto

type RiskCreateDTO struct {
	Title        string `json:"title" validate:"required,min=3,max=200"`
	Description  string `json:"description" validate:"max=5000"`
	Category     string `json:"category" validate:"max=200"`
	Source       string `json:"source" validate:"max=200"`
	AssetID      string `json:"asset_id" validate:"omitempty,uuid4"`
	ProcessID    string `json:"process_id" validate:"omitempty,uuid4"`
	IncidentID   string `json:"incident_id" validate:"omitempty,uuid4"`
	OwnerUserID  string `json:"owner_user_id" validate:"required,uuid4"`
	Methodology  string `json:"methodology" validate:"oneof=ISO27005 NIST COSO Custom"`
	Probability  string `json:"probability" validate:"required,oneof=low medium high very_high"`
	Impact       string `json:"impact" validate:"required,oneof=low medium high critical"`
	Strategy     string `json:"strategy" validate:"omitempty,oneof=accept mitigate transfer avoid"`
	DueDate      string `json:"due_date" validate:"omitempty,datetime=2006-01-02"`
	Tags         []string `json:"tags" validate:"dive,max=64"`
}

type RiskUpdateDTO struct {
	Title        *string  `json:"title" validate:"omitempty,min=3,max=200"`
	Description  *string  `json:"description" validate:"omitempty,max=5000"`
	Category     *string  `json:"category" validate:"omitempty,max=200"`
	Source       *string  `json:"source" validate:"omitempty,max=200"`
	OwnerUserID  *string  `json:"owner_user_id" validate:"omitempty,uuid4"`
	Status       *string  `json:"status" validate:"omitempty,oneof=new in_analysis in_treatment accepted transferred mitigated closed"`
	Methodology  *string  `json:"methodology" validate:"omitempty,oneof=ISO27005 NIST COSO Custom"`
	Probability  *string  `json:"probability" validate:"omitempty,oneof=low medium high very_high"`
	Impact       *string  `json:"impact" validate:"omitempty,oneof=low medium high critical"`
	Strategy     *string  `json:"strategy" validate:"omitempty,oneof=accept mitigate transfer avoid"`
	DueDate      *string  `json:"due_date" validate:"omitempty,datetime=2006-01-02"`
	Tags         *[]string `json:"tags" validate:"omitempty,dive,max=64"`
}

type RiskListFilters struct {
	Query      string   `query:"q"`
	Status     []string `query:"status"`
	Category   []string `query:"category"`
	OwnerIDs   []string `query:"owner"`
	Level      []string `query:"level"`
	Sort       string   `query:"sort"`  // created_at,-risk_score, etc.
	Limit      int      `query:"limit" validate:"gte=1,lte=200"`
	Offset     int      `query:"offset" validate:"gte=0"`
}

Сервисная логика (фрагмент)
// apps/backend/internal/domain/risk_service.go
package domain

import "errors"

type RiskRepo interface {
	Create(r *Risk, tags []string) error
	Update(id, tenantID string, patch map[string]interface{}, tags *([]string)) (*Risk, error)
	Get(id, tenantID string) (*Risk, error)
	List(tenantID string, f Filters) ([]Risk, int, error)
	LinkControl(tenantID, riskID, controlID string, plannedDate *string) error
	// ...
}

type RiskService struct {
	repo RiskRepo
}

func NewRiskService(r RiskRepo) *RiskService { return &RiskService{repo: r} }

func (s *RiskService) computeScore(prob RiskProbability, imp RiskImpact) int {
	pm := map[RiskProbability]int{ProbLow:1, ProbMedium:2, ProbHigh:3, ProbVeryHigh:4}
	im := map[RiskImpact]int{ImpactLow:1, ImpactMedium:2, ImpactHigh:3, ImpactCritical:4}
	return pm[prob] * im[imp]
}

func (s *RiskService) Create(dto Risk) (*Risk, error) {
	if dto.Title == "" { return nil, errors.New("title required") }
	dto.RiskScore = s.computeScore(dto.Probability, dto.Impact)
	// repo handles tags; omitted for brevity
	if err := s.repo.Create(&dto, nil); err != nil { return nil, err }
	return &dto, nil
}

4) Маршруты API (Fiber) + middleware

Базовый префикс: /api/v1/risks

Метод	Путь	Права	Назначение
GET	/	risk.read	Список с фильтрами и пагинацией
POST	/	risk.create	Создать риск
GET	/:id	risk.read	Получить риск
PATCH	/:id	risk.update	Обновить (partial)
DELETE	/:id	risk.delete	Удалить
POST	/:id/controls	risk.link.controls	Привязать контроль
DELETE	/:id/controls/:controlId	risk.link.controls	Отвязать контроль
POST	/:id/comments	risk.comment	Добавить комментарий
GET	/:id/history	risk.read	История изменений
GET	/export	risk.export	Экспорт CSV/XLSX
GET	/heatmap	risk.read	Агрегаты для матрицы риска
POST	/:id/attachments	risk.update	Загрузка вложения (multipart)
Примеры запросов/ответов

Создание риска

POST /api/v1/risks
Content-Type: application/json
Authorization: Bearer <JWT>

{
  "title": "Отказ системы Бэкапов",
  "description": "Потенциальная потеря данных при сбое в хранилище",
  "category": "Технические",
  "source": "Внутренний",
  "owner_user_id": "1e2f7d8a-...-c9",
  "methodology": "ISO27005",
  "probability": "high",
  "impact": "critical",
  "strategy": "mitigate",
  "due_date": "2025-10-31",
  "tags": ["backup","storage"]
}

HTTP/1.1 201 Created
{
  "id": "a7d1c3c5-...-4f",
  "tenant_id": "9c0e...54",
  "code": "RNX-RSK-000124",
  "title": "Отказ системы Бэкапов",
  "status": "new",
  "probability": "high",
  "impact": "critical",
  "risk_score": 12,
  "risk_level": "High",
  "created_at": "2025-10-02T19:45:13Z"
}


Список с фильтрами

GET /api/v1/risks?q=backup&status=in_treatment&level=High&limit=20&offset=0&sort=-risk_score


Привязка контроля

POST /api/v1/risks/a7d1.../controls
{
  "control_id": "c-1234-...-9",
  "planned_date": "2025-11-15"
}


Комментарии

POST /api/v1/risks/a7d1.../comments
{ "body": "Закупаем дополнительный репозиторий для копий." }

5) OpenAPI 3.1 (фрагмент)
openapi: 3.1.0
info:
  title: CompliSec Risk API
  version: "1.0.0"
servers:
  - url: /api/v1
paths:
  /risks:
    get:
      summary: List risks
      security: [{ BearerAuth: [] }]
      parameters:
        - in: query; name: q; schema: { type: string }
        - in: query; name: status; schema: { type: array, items: { type: string, enum: [new,in_analysis,in_treatment,accepted,transferred,mitigated,closed] } }, style: form, explode: true
        - in: query; name: level; schema: { type: array, items: { type: string, enum: [Low,Medium,High] } }, style: form, explode: true
        - in: query; name: owner; schema: { type: array, items: { type: string, format: uuid } }, style: form, explode: true
        - in: query; name: sort; schema: { type: string }
        - in: query; name: limit; schema: { type: integer, minimum: 1, maximum: 200 }
        - in: query; name: offset; schema: { type: integer, minimum: 0 }
      responses:
        "200":
          description: ok
          content:
            application/json:
              schema:
                type: object
                properties:
                  total: { type: integer }
                  items:
                    type: array
                    items: { $ref: "#/components/schemas/Risk" }
    post:
      summary: Create risk
      security: [{ BearerAuth: [] }]
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: "#/components/schemas/RiskCreate" }
      responses:
        "201":
          description: created
          content:
            application/json:
              schema: { $ref: "#/components/schemas/Risk" }

  /risks/{id}:
    get:
      summary: Get risk
      security: [{ BearerAuth: [] }]
      parameters:
        - in: path; name: id; required: true; schema: { type: string, format: uuid }
      responses:
        "200": { description: ok, content: { application/json: { schema: { $ref: "#/components/schemas/Risk" } } } }
    patch:
      summary: Update risk
      security: [{ BearerAuth: [] }]
      parameters:
        - in: path; name: id; required: true; schema: { type: string, format: uuid }
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: "#/components/schemas/RiskUpdate" }
      responses:
        "200": { description: ok, content: { application/json: { schema: { $ref: "#/components/schemas/Risk" } } } }
    delete:
      summary: Delete risk
      security: [{ BearerAuth: [] }]
      parameters:
        - in: path; name: id; required: true; schema: { type: string, format: uuid }
      responses: { "204": { description: deleted } }

  /risks/{id}/controls:
    post:
      summary: Link control to risk
      security: [{ BearerAuth: [] }]
      parameters: [ { in: path, name: id, required: true, schema: { type: string, format: uuid } } ]
      requestBody:
        content:
          application/json:
            schema:
              type: object
              required: [control_id]
              properties:
                control_id: { type: string, format: uuid }
                planned_date: { type: string, format: date }
      responses: { "204": { description: linked } }

  /risks/{id}/history:
    get:
      summary: Risk history
      security: [{ BearerAuth: [] }]
      parameters: [ { in: path, name: id, required: true, schema: { type: string, format: uuid } } ]
      responses:
        "200":
          description: ok
          content: { application/json: { schema: { type: array, items: { $ref: "#/components/schemas/RiskHistory" } } } }

components:
  securitySchemes:
    BearerAuth: { type: http, scheme: bearer, bearerFormat: JWT }
  schemas:
    Risk:
      type: object
      properties:
        id: { type: string, format: uuid }
        code: { type: string, nullable: true }
        title: { type: string }
        description: { type: string, nullable: true }
        category: { type: string, nullable: true }
        source: { type: string, nullable: true }
        owner_user_id: { type: string, format: uuid }
        status: { type: string, enum: [new,in_analysis,in_treatment,accepted,transferred,mitigated,closed] }
        methodology: { type: string }
        probability: { type: string, enum: [low,medium,high,very_high] }
        impact: { type: string, enum: [low,medium,high,critical] }
        risk_score: { type: integer }
        risk_level: { type: string, enum: [Low,Medium,High] }
        strategy: { type: string, nullable: true, enum: [accept,mitigate,transfer,avoid] }
        due_date: { type: string, format: date, nullable: true }
        created_at: { type: string, format: date-time }
        updated_at: { type: string, format: date-time }
    RiskCreate:
      type: object
      required: [title, owner_user_id, probability, impact]
      properties:
        title: { type: string, minLength: 3, maxLength: 200 }
        description: { type: string, maxLength: 5000 }
        category: { type: string }
        source: { type: string }
        owner_user_id: { type: string, format: uuid }
        methodology: { type: string, enum: [ISO27005, NIST, COSO, Custom], default: ISO27005 }
        probability: { type: string, enum: [low,medium,high,very_high] }
        impact: { type: string, enum: [low,medium,high,critical] }
        strategy: { type: string, enum: [accept,mitigate,transfer,avoid] }
        due_date: { type: string, format: date }
        tags:
          type: array
          items: { type: string, maxLength: 64 }
    RiskUpdate:
      type: object
      properties:
        title: { type: string }
        description: { type: string }
        category: { type: string }
        source: { type: string }
        owner_user_id: { type: string, format: uuid }
        status: { type: string, enum: [new,in_analysis,in_treatment,accepted,transferred,mitigated,closed] }
        methodology: { type: string, enum: [ISO27005, NIST, COSO, Custom] }
        probability: { type: string, enum: [low,medium,high,very_high] }
        impact: { type: string, enum: [low,medium,high,critical] }
        strategy: { type: string, enum: [accept,mitigate,transfer,avoid] }
        due_date: { type: string, format: date }
    RiskHistory:
      type: object
      properties:
        id: { type: string, format: uuid }
        change_type: { type: string }
        from_value: { type: object, additionalProperties: true }
        to_value: { type: object, additionalProperties: true }
        created_at: { type: string, format: date-time }

6) Бизнес-правила и автоматизация

Пересчет risk_score при изменении probability или impact. Логика — в сервисе; запись — в risks.risk_score.

Пороговые уведомления: при переходе risk_level в High → событие RiskEscalated → нотификация владельцу и роли Администратор ИБ.

Закрытие риска: status=closed требует close_reason и выставляет closed_at.

История: каждое изменение значимых полей записывать в risk_history (до/после).

Метки/теги: нормализованы через risk_tags и risk_tag_map; по API — массив строк.

Экспорт: сервер отдаёт CSV/XLSX (стриминг) с учетом фильтров и прав.

7) Ошибки и коды ответов

400 Bad Request — валидация DTO (сообщения из validator.v10).

401 Unauthorized — отсутствует/просрочен JWT.

403 Forbidden — нет нужного permission.

404 Not Found — риск/контроль не найден или чужой tenant.

409 Conflict — дублирующий code/связь контрола.

422 Unprocessable Entity — попытка закрыть без close_reason.

500 Internal Server Error — непредвиденная ошибка.

Структура ошибки:

{
  "error": "validation_error",
  "message": "field 'probability' must be one of ...",
  "details": { "probability": "oneof" }
}

8) UI/Frontend (кратко, для постановки задачи)

Список: фильтры (статус, владелец, уровень, категория, теги), поиск, сортировка, пагинация, быстрые действия (смена статуса).

Карточка: поля, вкладки Контроли, Комментарии, История, Вложения.

Heatmap: матрица 4×4; клик по ячейке — фильтрованный список.

Отчеты: экспорт текущего набора фильтров.

Права: скрывать/дизейблить элементы по permissions из профиля.

9) Таски для курсора (шаблоны)

Бэкенд

Создать миграции 01..08 (см. SQL выше).

Реализовать репозиторий RiskRepo (list, get, create, update, delete, linkControl, history, comments).

Мидлвари: извлечение tenant_id из JWT, проверка permissions.

Хэндлеры Fiber по таблице маршрутов (см. раздел 4).

Уведомления: интеграция с вашим нотификатором (email/Telegram/webhook) на событие RiskEscalated.

Тесты: unit на сервис/валидаторы, интеграционные на CRUD и права.

Фронтенд

Страницы: /risks, /risks/:id.

Компоненты: RiskList, RiskForm, RiskViewTabs (Controls, Comments, History, Attachments), RiskHeatmap.

Сервис API: методы по OpenAPI.

Отображение прав: HOC/guard withPermission.